"use strict";(self.webpackChunkfirehose=self.webpackChunkfirehose||[]).push([[253],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(n),h=a,f=m["".concat(p,".").concat(h)]||m[h]||u[h]||o;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2075:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={},p="Templating",l={unversionedId:"concepts/templating",id:"concepts/templating",title:"Templating",description:"Firehose HTTP sink supports payload templating using SINKHTTPJSONBODYTEMPLATE configuration. It uses JsonPath for creating Templates which is a DSL for basic JSON parsing. Playground for this//jsonpath.com/, where users can play around with a given JSON to extract out the elements as required and validate the jsonpath. The template works only when the output data format SINKHTTPDATAFORMAT is JSON.",source:"@site/docs/concepts/templating.md",sourceDirName:"concepts",slug:"/concepts/templating",permalink:"/firehose/concepts/templating",draft:!1,editUrl:"https://github.com/goto/firehose/edit/master/docs/docs/concepts/templating.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Filters",permalink:"/firehose/concepts/filters"},next:{title:"Firehose Consumer",permalink:"/firehose/concepts/consumer"}},c={},u=[],m={toc:u};function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"templating"},"Templating"),(0,o.kt)("p",null,"Firehose HTTP sink supports payload templating using ",(0,o.kt)("a",{parentName:"p",href:"/firehose/sinks/http-sink#sink_http_json_body_template"},(0,o.kt)("inlineCode",{parentName:"a"},"SINK_HTTP_JSON_BODY_TEMPLATE"))," configuration. It uses ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/json-path/JsonPath"},"JsonPath")," for creating Templates which is a DSL for basic JSON parsing. Playground for this: ",(0,o.kt)("a",{parentName:"p",href:"https://jsonpath.com/"},"https://jsonpath.com/"),", where users can play around with a given JSON to extract out the elements as required and validate the ",(0,o.kt)("inlineCode",{parentName:"p"},"jsonpath"),". The template works only when the output data format ",(0,o.kt)("a",{parentName:"p",href:"/firehose/sinks/http-sink#sink_http_data_format"},(0,o.kt)("inlineCode",{parentName:"a"},"SINK_HTTP_DATA_FORMAT"))," is JSON."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Creating Templates:"))),(0,o.kt)("p",null,"This is really simple. Find the paths you need to extract using the JSON path. Create a valid JSON template with the static field names + the paths that need to extract. ","(","Paths name starts with $.",")",". Firehose will simply replace the paths with the actual data in the path of the message accordingly. Paths can also be used on keys, but be careful that the element in the key must be a string data type."),(0,o.kt)("p",null,"One sample configuration","(","On XYZ proto",")"," : ",(0,o.kt)("inlineCode",{parentName:"p"},'{"test":"$.routes[0]", "$.order_number" : "xxx"}')," If you want to dump the entire JSON as it is in the backend, use ",(0,o.kt)("inlineCode",{parentName:"p"},'"$._all_"')," as a path."),(0,o.kt)("p",null,"Limitations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Works when the input DATA TYPE is a protobuf, not a JSON."),(0,o.kt)("li",{parentName:"ul"},"Supports only on messages, not keys."),(0,o.kt)("li",{parentName:"ul"},"validation on the level of valid JSON template. But after data has been replaced the resulting string may or may not be a valid JSON. Users must do proper testing/validation from the service side."),(0,o.kt)("li",{parentName:"ul"},"If selecting fields from complex data types like repeated/messages/map of proto, the user must do filtering based first as selecting a field that does not exist would fail.")))}h.isMDXComponent=!0}}]);